"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/helpers.ts":
/*!******************************!*\
  !*** ./src/utils/helpers.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatCurrency: function() { return /* binding */ formatCurrency; },\n/* harmony export */   getGameImage: function() { return /* binding */ getGameImage; },\n/* harmony export */   parseCommaString: function() { return /* binding */ parseCommaString; },\n/* harmony export */   parseMediaString: function() { return /* binding */ parseMediaString; },\n/* harmony export */   parseMovieUrls: function() { return /* binding */ parseMovieUrls; },\n/* harmony export */   truncateText: function() { return /* binding */ truncateText; }\n/* harmony export */ });\n/**\r\n * Format currency in Vietnamese Dong (VND)\r\n */ function formatCurrency(amount) {\n    return new Intl.NumberFormat(\"vi-VN\", {\n        style: \"currency\",\n        currency: \"VND\",\n        maximumFractionDigits: 0\n    }).format(amount);\n}\n/**\r\n * Clean Python-style array string to extract URLs\r\n * Handles format like: \"['url1', 'url2']\" or \"[{...}]\"\r\n */ function cleanPythonArrayString(data) {\n    // Remove leading/trailing brackets and whitespace\n    let cleaned = data.trim();\n    // Check if it's wrapped in brackets\n    if (cleaned.startsWith(\"[\") && cleaned.endsWith(\"]\")) {\n        // Replace single quotes with double quotes for JSON parsing\n        cleaned = cleaned.replace(/'/g, '\"');\n    }\n    return cleaned;\n}\n/**\r\n * Parse a media string (screenshots or movies) into an array of URLs\r\n * Handles JSON arrays, Python-style arrays, and comma-separated strings\r\n */ function parseMediaString(data) {\n    if (!data) return [];\n    const trimmedData = data.trim();\n    // Clean Python-style arrays first (single quotes to double quotes)\n    const cleanedData = cleanPythonArrayString(trimmedData);\n    // Try parsing as JSON\n    try {\n        const parsed = JSON.parse(cleanedData);\n        if (Array.isArray(parsed)) {\n            // If it's an array of objects with path_full or url property\n            if (parsed.length > 0 && typeof parsed[0] === \"object\") {\n                return parsed.map((item)=>item.path_full || item.url || item.path_thumbnail || \"\").filter(Boolean);\n            }\n            // If it's an array of strings\n            return parsed.filter((item)=>typeof item === \"string\" && item.startsWith(\"http\"));\n        }\n    } catch (e) {\n    // Not valid JSON, try other methods\n    }\n    // Handle comma-separated URL strings\n    if (trimmedData.includes(\",\")) {\n        // Extract all URLs using regex\n        const urlMatches = trimmedData.match(/https?:\\/\\/[^\\s,'\"\\]]+/g);\n        if (urlMatches && urlMatches.length > 0) {\n            return urlMatches;\n        }\n    }\n    // Single URL\n    if (trimmedData.startsWith(\"http\")) {\n        return [\n            trimmedData\n        ];\n    }\n    // Try to extract URLs from malformed string\n    const urlMatches = trimmedData.match(/https?:\\/\\/[^\\s,'\"\\]]+/g);\n    if (urlMatches && urlMatches.length > 0) {\n        return urlMatches;\n    }\n    return [];\n}\n/**\r\n * Get the game header image with Steam CDN fallback\r\n */ function getGameImage(game) {\n    if (game.header_image) {\n        // Check if header_image is a malformed array string\n        if (game.header_image.startsWith(\"[\")) {\n            const urls = parseMediaString(game.header_image);\n            if (urls.length > 0) {\n                return urls[0];\n            }\n        }\n        return game.header_image;\n    }\n    // Fallback to Steam CDN\n    return \"https://shared.akamai.steamstatic.com/store_item_assets/steam/apps/\".concat(game.appid, \"/header.jpg\");\n}\n/**\r\n * Parse comma-separated string into trimmed array\r\n */ function parseCommaString(data) {\n    if (!data) return [];\n    return data.split(\",\").map((s)=>s.trim()).filter(Boolean);\n}\n/**\r\n * Parse movie URLs - extracts video URLs from movies JSON/string\r\n */ function parseMovieUrls(data) {\n    if (!data) return [];\n    const trimmedData = data.trim();\n    const cleanedData = cleanPythonArrayString(trimmedData);\n    try {\n        const parsed = JSON.parse(cleanedData);\n        if (Array.isArray(parsed)) {\n            const urls = [];\n            for (const movie of parsed){\n                if (typeof movie === \"object\" && movie !== null) {\n                    var _movie_mp4, _movie_mp41, _movie_webm;\n                    // Handle Steam movie format: { mp4: { max: url, 480: url }, webm: { max: url } }\n                    const mp4Max = ((_movie_mp4 = movie.mp4) === null || _movie_mp4 === void 0 ? void 0 : _movie_mp4.max) || ((_movie_mp41 = movie.mp4) === null || _movie_mp41 === void 0 ? void 0 : _movie_mp41[\"480\"]);\n                    const webmMax = (_movie_webm = movie.webm) === null || _movie_webm === void 0 ? void 0 : _movie_webm.max;\n                    const directUrl = movie.url || movie.path_full;\n                    if (mp4Max) urls.push(mp4Max);\n                    else if (webmMax) urls.push(webmMax);\n                    else if (directUrl) urls.push(directUrl);\n                } else if (typeof movie === \"string\" && movie.startsWith(\"http\")) {\n                    urls.push(movie);\n                }\n            }\n            return urls;\n        }\n    } catch (e) {\n    // Not valid JSON\n    }\n    // Try to extract video URLs using regex\n    const videoMatches = trimmedData.match(/https?:\\/\\/[^\\s,'\"\\]]+\\.(mp4|webm)[^\\s,'\"\\]]*/gi);\n    if (videoMatches && videoMatches.length > 0) {\n        return videoMatches;\n    }\n    // Fall back to generic parsing\n    const urls = parseMediaString(data);\n    return urls.filter((url)=>url.includes(\".mp4\") || url.includes(\".webm\"));\n}\n/**\r\n * Truncate text to a maximum length with ellipsis\r\n */ function truncateText(text, maxLength) {\n    if (text.length <= maxLength) return text;\n    return text.slice(0, maxLength).trim() + \"...\";\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9oZWxwZXJzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUVBOztDQUVDLEdBQ00sU0FBU0EsZUFBZUMsTUFBYztJQUN6QyxPQUFPLElBQUlDLEtBQUtDLFlBQVksQ0FBQyxTQUFTO1FBQ2xDQyxPQUFPO1FBQ1BDLFVBQVU7UUFDVkMsdUJBQXVCO0lBQzNCLEdBQUdDLE1BQU0sQ0FBQ047QUFDZDtBQUVBOzs7Q0FHQyxHQUNELFNBQVNPLHVCQUF1QkMsSUFBWTtJQUN4QyxrREFBa0Q7SUFDbEQsSUFBSUMsVUFBVUQsS0FBS0UsSUFBSTtJQUV2QixvQ0FBb0M7SUFDcEMsSUFBSUQsUUFBUUUsVUFBVSxDQUFDLFFBQVFGLFFBQVFHLFFBQVEsQ0FBQyxNQUFNO1FBQ2xELDREQUE0RDtRQUM1REgsVUFBVUEsUUFBUUksT0FBTyxDQUFDLE1BQU07SUFDcEM7SUFFQSxPQUFPSjtBQUNYO0FBRUE7OztDQUdDLEdBQ00sU0FBU0ssaUJBQWlCTixJQUFtQjtJQUNoRCxJQUFJLENBQUNBLE1BQU0sT0FBTyxFQUFFO0lBRXBCLE1BQU1PLGNBQWNQLEtBQUtFLElBQUk7SUFFN0IsbUVBQW1FO0lBQ25FLE1BQU1NLGNBQWNULHVCQUF1QlE7SUFFM0Msc0JBQXNCO0lBQ3RCLElBQUk7UUFDQSxNQUFNRSxTQUFTQyxLQUFLQyxLQUFLLENBQUNIO1FBQzFCLElBQUlJLE1BQU1DLE9BQU8sQ0FBQ0osU0FBUztZQUN2Qiw2REFBNkQ7WUFDN0QsSUFBSUEsT0FBT0ssTUFBTSxHQUFHLEtBQUssT0FBT0wsTUFBTSxDQUFDLEVBQUUsS0FBSyxVQUFVO2dCQUNwRCxPQUFPQSxPQUFPTSxHQUFHLENBQUMsQ0FBQ0MsT0FDZkEsS0FBS0MsU0FBUyxJQUFJRCxLQUFLRSxHQUFHLElBQUlGLEtBQUtHLGNBQWMsSUFBSSxJQUN2REMsTUFBTSxDQUFDQztZQUNiO1lBQ0EsOEJBQThCO1lBQzlCLE9BQU9aLE9BQU9XLE1BQU0sQ0FBQyxDQUFD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TSxHQUFHLEdBQUc7UUFDekMsT0FBTzRCO0lBQ1g7SUFFQSwrQkFBK0I7SUFDL0IsTUFBTWQsT0FBT3RCLGlCQUFpQk47SUFDOUIsT0FBTzRCLEtBQUtSLE1BQU0sQ0FBQ0YsQ0FBQUEsTUFBT0EsSUFBSUksUUFBUSxDQUFDLFdBQVdKLElBQUlJLFFBQVEsQ0FBQztBQUNuRTtBQUVBOztDQUVDLEdBQ00sU0FBU3FCLGFBQWFDLElBQVksRUFBRUMsU0FBaUI7SUFDeEQsSUFBSUQsS0FBSzlCLE1BQU0sSUFBSStCLFdBQVcsT0FBT0Q7SUFDckMsT0FBT0EsS0FBS0UsS0FBSyxDQUFDLEdBQUdELFdBQVczQyxJQUFJLEtBQUs7QUFDN0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL2hlbHBlcnMudHM/NjlhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHYW1lIH0gZnJvbSAnQC90eXBlcy9nYW1lJztcclxuXHJcbi8qKlxyXG4gKiBGb3JtYXQgY3VycmVuY3kgaW4gVmlldG5hbWVzZSBEb25nIChWTkQpXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0Q3VycmVuY3koYW1vdW50OiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIG5ldyBJbnRsLk51bWJlckZvcm1hdCgndmktVk4nLCB7XHJcbiAgICAgICAgc3R5bGU6ICdjdXJyZW5jeScsXHJcbiAgICAgICAgY3VycmVuY3k6ICdWTkQnLFxyXG4gICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMCxcclxuICAgIH0pLmZvcm1hdChhbW91bnQpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2xlYW4gUHl0aG9uLXN0eWxlIGFycmF5IHN0cmluZyB0byBleHRyYWN0IFVSTHNcclxuICogSGFuZGxlcyBmb3JtYXQgbGlrZTogXCJbJ3VybDEnLCAndXJsMiddXCIgb3IgXCJbey4uLn1dXCJcclxuICovXHJcbmZ1bmN0aW9uIGNsZWFuUHl0aG9uQXJyYXlTdHJpbmcoZGF0YTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIC8vIFJlbW92ZSBsZWFkaW5nL3RyYWlsaW5nIGJyYWNrZXRzIGFuZCB3aGl0ZXNwYWNlXHJcbiAgICBsZXQgY2xlYW5lZCA9IGRhdGEudHJpbSgpO1xyXG5cclxuICAgIC8vIENoZWNrIGlmIGl0J3Mgd3JhcHBlZCBpbiBicmFja2V0c1xyXG4gICAgaWYgKGNsZWFuZWQuc3RhcnRzV2l0aCgnWycpICYmIGNsZWFuZWQuZW5kc1dpdGgoJ10nKSkge1xyXG4gICAgICAgIC8vIFJlcGxhY2Ugc2luZ2xlIHF1b3RlcyB3aXRoIGRvdWJsZSBxdW90ZXMgZm9yIEpTT04gcGFyc2luZ1xyXG4gICAgICAgIGNsZWFuZWQgPSBjbGVhbmVkLnJlcGxhY2UoLycvZywgJ1wiJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNsZWFuZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBhIG1lZGlhIHN0cmluZyAoc2NyZWVuc2hvdHMgb3IgbW92aWVzKSBpbnRvIGFuIGFycmF5IG9mIFVSTHNcclxuICogSGFuZGxlcyBKU09OIGFycmF5cywgUHl0aG9uLXN0eWxlIGFycmF5cywgYW5kIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmdzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNZWRpYVN0cmluZyhkYXRhOiBzdHJpbmcgfCBudWxsKTogc3RyaW5nW10ge1xyXG4gICAgaWYgKCFkYXRhKSByZXR1cm4gW107XHJcblxyXG4gICAgY29uc3QgdHJpbW1lZERhdGEgPSBkYXRhLnRyaW0oKTtcclxuXHJcbiAgICAvLyBDbGVhbiBQeXRob24tc3R5bGUgYXJyYXlzIGZpcnN0IChzaW5nbGUgcXVvdGVzIHRvIGRvdWJsZSBxdW90ZXMpXHJcbiAgICBjb25zdCBjbGVhbmVkRGF0YSA9IGNsZWFuUHl0aG9uQXJyYXlTdHJpbmcodHJpbW1lZERhdGEpO1xyXG5cclxuICAgIC8vIFRyeSBwYXJzaW5nIGFzIEpTT05cclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShjbGVhbmVkRGF0YSk7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VkKSkge1xyXG4gICAgICAgICAgICAvLyBJZiBpdCdzIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBwYXRoX2Z1bGwgb3IgdXJsIHByb3BlcnR5XHJcbiAgICAgICAgICAgIGlmIChwYXJzZWQubGVuZ3RoID4gMCAmJiB0eXBlb2YgcGFyc2VkWzBdID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZC5tYXAoKGl0ZW06IHsgcGF0aF9mdWxsPzogc3RyaW5nOyB1cmw/OiBzdHJpbmc7IHBhdGhfdGh1bWJuYWlsPzogc3RyaW5nIH0pID0+XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5wYXRoX2Z1bGwgfHwgaXRlbS51cmwgfHwgaXRlbS5wYXRoX3RodW1ibmFpbCB8fCAnJ1xyXG4gICAgICAgICAgICAgICAgKS5maWx0ZXIoQm9vbGVhbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgaXQncyBhbiBhcnJheSBvZiBzdHJpbmdzXHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQuZmlsdGVyKChpdGVtKTogaXRlbSBpcyBzdHJpbmcgPT4gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnICYmIGl0ZW0uc3RhcnRzV2l0aCgnaHR0cCcpKTtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgICAvLyBOb3QgdmFsaWQgSlNPTiwgdHJ5IG90aGVyIG1ldGhvZHNcclxuICAgIH1cclxuXHJcbiAgICAvLyBIYW5kbGUgY29tbWEtc2VwYXJhdGVkIFVSTCBzdHJpbmdzXHJcbiAgICBpZiAodHJpbW1lZERhdGEuaW5jbHVkZXMoJywnKSkge1xyXG4gICAgICAgIC8vIEV4dHJhY3QgYWxsIFVSTHMgdXNpbmcgcmVnZXhcclxuICAgICAgICBjb25zdCB1cmxNYXRjaGVzID0gdHJpbW1lZERhdGEubWF0Y2goL2h0dHBzPzpcXC9cXC9bXlxccywnXCJcXF1dKy9nKTtcclxuICAgICAgICBpZiAodXJsTWF0Y2hlcyAmJiB1cmxNYXRjaGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVybE1hdGNoZXM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNpbmdsZSBVUkxcclxuICAgIGlmICh0cmltbWVkRGF0YS5zdGFydHNXaXRoKCdodHRwJykpIHtcclxuICAgICAgICByZXR1cm4gW3RyaW1tZWREYXRhXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUcnkgdG8gZXh0cmFjdCBVUkxzIGZyb20gbWFsZm9ybWVkIHN0cmluZ1xyXG4gICAgY29uc3QgdXJsTWF0Y2hlcyA9IHRyaW1tZWREYXRhLm1hdGNoKC9odHRwcz86XFwvXFwvW15cXHMsJ1wiXFxdXSsvZyk7XHJcbiAgICBpZiAodXJsTWF0Y2hlcyAmJiB1cmxNYXRjaGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICByZXR1cm4gdXJsTWF0Y2hlcztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGdhbWUgaGVhZGVyIGltYWdlIHdpdGggU3RlYW0gQ0ROIGZhbGxiYWNrXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2FtZUltYWdlKGdhbWU6IEdhbWUpOiBzdHJpbmcge1xyXG4gICAgaWYgKGdhbWUuaGVhZGVyX2ltYWdlKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgaGVhZGVyX2ltYWdlIGlzIGEgbWFsZm9ybWVkIGFycmF5IHN0cmluZ1xyXG4gICAgICAgIGlmIChnYW1lLmhlYWRlcl9pbWFnZS5zdGFydHNXaXRoKCdbJykpIHtcclxuICAgICAgICAgICAgY29uc3QgdXJscyA9IHBhcnNlTWVkaWFTdHJpbmcoZ2FtZS5oZWFkZXJfaW1hZ2UpO1xyXG4gICAgICAgICAgICBpZiAodXJscy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsc1swXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ2FtZS5oZWFkZXJfaW1hZ2U7XHJcbiAgICB9XHJcbiAgICAvLyBGYWxsYmFjayB0byBTdGVhbSBDRE5cclxuICAgIHJldHVybiBgaHR0cHM6Ly9zaGFyZWQuYWthbWFpLnN0ZWFtc3RhdGljLmNvbS9zdG9yZV9pdGVtX2Fzc2V0cy9zdGVhbS9hcHBzLyR7Z2FtZS5hcHBpZH0vaGVhZGVyLmpwZ2A7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZSBjb21tYS1zZXBhcmF0ZWQgc3RyaW5nIGludG8gdHJpbW1lZCBhcnJheVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29tbWFTdHJpbmcoZGF0YTogc3RyaW5nIHwgbnVsbCk6IHN0cmluZ1tdIHtcclxuICAgIGlmICghZGF0YSkgcmV0dXJuIFtdO1xyXG4gICAgcmV0dXJuIGRhdGEuc3BsaXQoJywnKS5tYXAocyA9PiBzLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pO1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2UgbW92aWUgVVJMcyAtIGV4dHJhY3RzIHZpZGVvIFVSTHMgZnJvbSBtb3ZpZXMgSlNPTi9zdHJpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1vdmllVXJscyhkYXRhOiBzdHJpbmcgfCBudWxsKTogc3RyaW5nW10ge1xyXG4gICAgaWYgKCFkYXRhKSByZXR1cm4gW107XHJcblxyXG4gICAgY29uc3QgdHJpbW1lZERhdGEgPSBkYXRhLnRyaW0oKTtcclxuICAgIGNvbnN0IGNsZWFuZWREYXRhID0gY2xlYW5QeXRob25BcnJheVN0cmluZyh0cmltbWVkRGF0YSk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGNsZWFuZWREYXRhKTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVybHM6IHN0cmluZ1tdID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1vdmllIG9mIHBhcnNlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtb3ZpZSA9PT0gJ29iamVjdCcgJiYgbW92aWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgU3RlYW0gbW92aWUgZm9ybWF0OiB7IG1wNDogeyBtYXg6IHVybCwgNDgwOiB1cmwgfSwgd2VibTogeyBtYXg6IHVybCB9IH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtcDRNYXggPSBtb3ZpZS5tcDQ/Lm1heCB8fCBtb3ZpZS5tcDQ/LlsnNDgwJ107XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2VibU1heCA9IG1vdmllLndlYm0/Lm1heDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3RVcmwgPSBtb3ZpZS51cmwgfHwgbW92aWUucGF0aF9mdWxsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobXA0TWF4KSB1cmxzLnB1c2gobXA0TWF4KTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh3ZWJtTWF4KSB1cmxzLnB1c2god2VibU1heCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0VXJsKSB1cmxzLnB1c2goZGlyZWN0VXJsKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vdmllID09PSAnc3RyaW5nJyAmJiBtb3ZpZS5zdGFydHNXaXRoKCdodHRwJykpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cmxzLnB1c2gobW92aWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdXJscztcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgICAvLyBOb3QgdmFsaWQgSlNPTlxyXG4gICAgfVxyXG5cclxuICAgIC8vIFRyeSB0byBleHRyYWN0IHZpZGVvIFVSTHMgdXNpbmcgcmVnZXhcclxuICAgIGNvbnN0IHZpZGVvTWF0Y2hlcyA9IHRyaW1tZWREYXRhLm1hdGNoKC9odHRwcz86XFwvXFwvW15cXHMsJ1wiXFxdXStcXC4obXA0fHdlYm0pW15cXHMsJ1wiXFxdXSovZ2kpO1xyXG4gICAgaWYgKHZpZGVvTWF0Y2hlcyAmJiB2aWRlb01hdGNoZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHJldHVybiB2aWRlb01hdGNoZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmFsbCBiYWNrIHRvIGdlbmVyaWMgcGFyc2luZ1xyXG4gICAgY29uc3QgdXJscyA9IHBhcnNlTWVkaWFTdHJpbmcoZGF0YSk7XHJcbiAgICByZXR1cm4gdXJscy5maWx0ZXIodXJsID0+IHVybC5pbmNsdWRlcygnLm1wNCcpIHx8IHVybC5pbmNsdWRlcygnLndlYm0nKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcnVuY2F0ZSB0ZXh0IHRvIGEgbWF4aW11bSBsZW5ndGggd2l0aCBlbGxpcHNpc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRydW5jYXRlVGV4dCh0ZXh0OiBzdHJpbmcsIG1heExlbmd0aDogbnVtYmVyKTogc3RyaW5nIHtcclxuICAgIGlmICh0ZXh0Lmxlbmd0aCA8PSBtYXhMZW5ndGgpIHJldHVybiB0ZXh0O1xyXG4gICAgcmV0dXJuIHRleHQuc2xpY2UoMCwgbWF4TGVuZ3RoKS50cmltKCkgKyAnLi4uJztcclxufVxyXG5cclxuIl0sIm5hbWVzIjpbImZvcm1hdEN1cnJlbmN5IiwiYW1vdW50IiwiSW50bCIsIk51bWJlckZvcm1hdCIsInN0eWxlIiwiY3VycmVuY3kiLCJtYXhpbXVtRnJhY3Rpb25EaWdpdHMiLCJmb3JtYXQiLCJjbGVhblB5dGhvbkFycmF5U3RyaW5nIiwiZGF0YSIsImNsZWFuZWQiLCJ0cmltIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwicmVwbGFjZSIsInBhcnNlTWVkaWFTdHJpbmciLCJ0cmltbWVkRGF0YSIsImNsZWFuZWREYXRhIiwicGFyc2VkIiwiSlNPTiIsInBhcnNlIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwibWFwIiwiaXRlbSIsInBhdGhfZnVsbCIsInVybCIsInBhdGhfdGh1bWJuYWlsIiwiZmlsdGVyIiwiQm9vbGVhbiIsImluY2x1ZGVzIiwidXJsTWF0Y2hlcyIsIm1hdGNoIiwiZ2V0R2FtZUltYWdlIiwiZ2FtZSIsImhlYWRlcl9pbWFnZSIsInVybHMiLCJhcHBpZCIsInBhcnNlQ29tbWFTdHJpbmciLCJzcGxpdCIsInMiLCJwYXJzZU1vdmllVXJscyIsIm1vdmllIiwibXA0TWF4IiwibXA0IiwibWF4Iiwid2VibU1heCIsIndlYm0iLCJkaXJlY3RVcmwiLCJwdXNoIiwidmlkZW9NYXRjaGVzIiwidHJ1bmNhdGVUZXh0IiwidGV4dCIsIm1heExlbmd0aCIsInNsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/helpers.ts\n"));

/***/ })

});